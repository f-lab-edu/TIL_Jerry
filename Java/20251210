[개요]
- 첫 멘토링 실시. 자바의 신을 활용한 질의 응답이 이루어졌는데, 단 한 개도 똑바로 된 대답을 하지 못하는 대참사가 발생.
질문 정리
•  자바에서 객체가 상태를 갖는 것이 어떤 사이드 이펙트를 만들어낼 수 있나요?
•  불변 객체와 가변 객체의 차이점과 각각의 장단점은 무엇인가요?
•  컴파일과 런타임의 차이점에 대해 설명해보세요.
•  자바의 바이트코드가 가지는 의미와 장점은 무엇인가요?
•  프리미티브 타입과 레퍼런스 타입의 기본값 차이와 그로 인한 실무적 영향은 무엇인가요?
•  부동 소수점 연산이 금전 계산에 적합하지 않은 이유는 무엇인가요?
•  오버플로우/언더플로우가 발생하는 원리와, 이진수의 2의 보수 표현 방식에 대해 설명해보세요.
•  단락 평가(short-circuit evaluation)와 비트 연산자의 차이점 및 각각의 장단점은 무엇인가요?
•  비트 플래그(bit flag)와 비트 마스킹의 실무적 활용 예시는 무엇인가요?
•  클래스와 객체의 차이점, 그리고 인터페이스의 의미론적/문법적 차이에 대해 설명해보세요.
인사이트 정리
•  객체가 상태를 가질 때, 외부에서 세터를 통해 상태가 변경될 수 있어 추적이 어렵고 멀티스레드 환경에서 동기화 문제가 발생할 수 있다.
•  불변 객체는 멀티스레드 환경에서 안전하며, 전달 시 상태 변경 위험이 없어 설계상 권장된다.
•  자바의 컴파일 과정은 바이트코드라는 중간 언어를 생성하고, JVM이 이를 OS/CPU에 맞게 실행한다.
•  JIT 컴파일러는 자주 실행되는 코드를 최적화하여 성능을 향상시키며, 초기 실행 시 성능 저하가 발생할 수 있어 웜업 과정이 필요하다.
•  프리미티브 타입은 널(null)을 가질 수 없고, 레퍼런스 타입은 널을 기본값으로 갖는다. 이로 인해 메서드 파라미터 처리, 메모리 사용, 예외 처리에 차이가 발생한다.
•  부동 소수점 연산은 이진수 표현의 한계로 인해 오차가 발생하며, 금전 계산에는 빅데시멀 등 정밀한 타입을 사용해야 한다.
•  2의 보수 표현 방식과 부호 비트 개념을 이해하면 오버플로우/언더플로우 현상을 예측하고 디버깅에 활용할 수 있다.
•  단락 평가(Short-circuit evaluation)는 효율적이지만, 함수 호출이 생략되어 의도치 않은 사이드 이펙트가 발생할 수 있다.
•  비트 연산자는 단락 평가 없이 모든 피연산자를 평가하며, 비트 플래그/마스킹을 통해 메모리와 네트워크 트래픽을 최적화할 수 있다.
•  비트 플래그는 여러 불리언 상태를 한 바이트로 관리할 수 있어 대규모 데이터 처리에 유리하다.
•  코딩 컨벤션(네이밍 규칙)은 협업과 유지보수에 필수적이며, 파스칼/카멜/스네이크 케이스 등 다양한 표준이 존재한다.
•  엔트리 포인트(main 메서드)는 프로그램 실행의 시작점이며, static이어야 객체 생성 없이 호출 가능하다.
•  TCP/IP 소켓 추상화는 OS별 차이를 감추고, 프레임워크(예: Netty)가 내부적으로 최적화된 방식을 선택한다.
•  CPU는 정수 연산에, GPU는 대규모 부동 소수점 연산에 특화되어 있다.
•  객체의 책임 분리는 설계의 핵심이며, 관심사 분리를 통해 유지보수성과 확장성을 높일 수 있다.